use std::marker::PhantomData;

use ff::PrimeField;
use halo2_proofs::arithmetic::CurveAffine;

use crate::{
    commitment::CommitmentKey,
    plonk::{PlonkStructure, PlonkTrace, RelaxedPlonkInstance, RelaxedPlonkTrace},
};

use super::*;

mod pow_i;
pub use pow_i::{iter_eval_of_pow_i, Error as PowIError};

/// ProtoGalaxy: Non Interactive Folding Scheme that implements main protocol defined in paper
/// [protogalaxy](https://eprint.iacr.org/2023/1106)
///
#[derive(Clone, Debug)]
pub struct ProtoGalaxy<C: CurveAffine> {
    _marker: PhantomData<C>,
}

pub struct ProtoGalaxyProverParam<C: CurveAffine> {
    pub(crate) S: PlonkStructure<C::ScalarExt>,
    /// digest of public parameter of IVC circuit
    pp_digest: C,
}

pub struct ProtoGalaxyProof<F: PrimeField> {
    // TODO: add comments
    pub poly_F: Vec<F>,
    pub poly_K: Vec<F>,
}

impl<C: CurveAffine> FoldingScheme<C> for ProtoGalaxy<C> {
    type ProverParam = ProtoGalaxyProverParam<C>;
    type VerifierParam = C;
    type Accumulator = RelaxedPlonkTrace<C>;
    type AccumulatorInstance = RelaxedPlonkInstance<C>;
    type Proof = ProtoGalaxyProof<C::ScalarExt>;

    fn setup_params(
        pp_digest: C,
        S: PlonkStructure<C::ScalarExt>,
    ) -> Result<(Self::ProverParam, Self::VerifierParam), Error> {
        Ok((ProtoGalaxyProverParam { S, pp_digest }, pp_digest))
    }

    // TODO: if this function turned out to be the same, consider move to trait
    fn generate_plonk_trace(
        ck: &CommitmentKey<C>,
        instance: &[C::ScalarExt],
        witness: &[Vec<C::ScalarExt>],
        pp: &Self::ProverParam,
        ro_nark: &mut impl ROTrait<C::Base>,
    ) -> Result<PlonkTrace<C>, Error> {
        let (u, w) =
            pp.S.run_sps_protocol(ck, instance, witness, ro_nark, pp.S.num_challenges)?;
        Ok(PlonkTrace { u, w })
    }

    fn prove(
        ck: &CommitmentKey<C>,
        pp: &Self::ProverParam,
        ro_acc: &mut impl ROTrait<C::Base>,
        accumulator: &Self::Accumulator,
        incoming: &PlonkTrace<C>,
    ) -> Result<(Self::Accumulator, Self::Proof), Error> {
        // TODO: avoid clone of the trace?
        Self::prove_mult(ck, pp, ro_acc, accumulator, &[incoming.clone()])
    }

    fn verify(
        vp: &Self::VerifierParam,
        ro_nark: &mut impl ROTrait<C::Base>,
        ro_acc: &mut impl ROTrait<C::Base>,
        accumulator: &Self::AccumulatorInstance,
        incoming: &PlonkInstance<C>,
        proof: &Self::Proof,
    ) -> Result<Self::AccumulatorInstance, Error> {
        Self::verify_mult(vp, ro_nark, ro_acc, accumulator, &[incoming.clone()], proof)
    }
}

impl<C: CurveAffine> MultifoldingScheme<C> for ProtoGalaxy<C> {
    /// Generates multi-folding proof using the protogalaxy protocol.
    ///
    /// This method takes one accumulator instance-witness pair and multiple incoming instance-witness pair
    /// then output the new folded accumulator instance-witness pair
    ///
    /// # Arguments
    /// * `ck`: The commitment key.
    /// * `pp`: The prover parameter.
    /// * `ro_acc`: The random oracle for the accumulation scheme. Used to securely combine
    ///             multiple verification steps or proofs into a single, updated accumulator.
    /// * `accumulator`: The instance-witness pair for accumulator
    /// * `incoming`: a vector of instance-witness pair from synthesize of circuit
    ///
    /// # Returns
    /// A tuple containing folded accumulator and proof for the multi-folding verifier
    fn prove_mult(
        _ck: &CommitmentKey<C>,
        _pp: &Self::ProverParam,
        _ro_acc: &mut impl ROTrait<C::Base>,
        _accumulator: &Self::Accumulator,
        _incoming: &[PlonkTrace<C>],
    ) -> Result<(Self::Accumulator, Self::Proof), Error> {
        todo!()
    }

    /// Verifies the correctness of the multi-folding prover defined in the protogalaxy protocol.
    ///
    /// This method takes a accumulator instance and multiple incoming instances
    /// then it generated the new accumulator instance
    ///
    /// # Arguments
    /// * `vp`: verifier parameter
    /// * `ro_acc`: The random oracle for the accumulation scheme. Used to securely combine
    ///             multiple verification steps or proofs into a single, updated accumulator.
    /// * `ro_nark`: The random oracle used within the non-interactive argument of knowledge (NARK)
    ///              system. Facilitates the Fiat-Shamir transformation, converting interactive
    ///              proofs to non-interactive by deterministically generating challenges based
    ///              on the protocol's messages.
    /// * `accumulator`: The Accumulator instance.
    /// * `incoming`:  a vector of instances to be folded
    /// * `proof`:   the proof generated by prove_mult
    ///
    /// # Returns
    /// The new folded accumulator instance
    fn verify_mult(
        _vp: &Self::VerifierParam,
        _ro_nark: &mut impl ROTrait<C::Base>,
        _ro_acc: &mut impl ROTrait<C::Base>,
        _accumulator: &Self::AccumulatorInstance,
        _incoming: &[PlonkInstance<C>],
        _proof: &Self::Proof,
    ) -> Result<Self::AccumulatorInstance, Error> {
        todo!()
    }
}

mod poly {
    use std::num::{NonZeroU32, NonZeroUsize};

    use ff::{Field, PrimeField};
    use halo2curves::CurveAffine;
    use itertools::Itertools;
    use rayon::prelude::*;

    use crate::{
        fft,
        plonk::{self, eval, GetChallenges, GetWitness, PlonkStructure},
        polynomial::{lagrange, univariate::UnivariatePoly},
    };

    use super::pow_i;

    fn compute_F_poly<C: CurveAffine>(
        beta: C::ScalarExt,
        delta: C::ScalarExt,
        S: &PlonkStructure<C::ScalarExt>,
        trace: &(impl Sync + GetChallenges<C::ScalarExt> + GetWitness<C::ScalarExt>),
    ) -> Result<UnivariatePoly<C::ScalarExt>, eval::Error> {
        struct ZipWitnessPowIterators<F, I, P, E>
        where
            F: PrimeField,
            I: Iterator<Item = Result<F, E>>,
            P: Iterator<Item = F>,
        {
            evaluated_witness: I,
            pow_i: Box<[P]>,
        }

        impl<F, I, P, E> Iterator for ZipWitnessPowIterators<F, I, P, E>
        where
            F: PrimeField,
            I: Iterator<Item = Result<F, E>>,
            P: Iterator<Item = F>,
        {
            type Item = Result<Box<[F]>, E>;

            fn next(&mut self) -> Option<Self::Item> {
                let evaluated_witness = match self.evaluated_witness.next()? {
                    Ok(w) => w,
                    Err(err) => {
                        return Some(Err(err));
                    }
                };

                Ok(self
                    .pow_i
                    .iter_mut()
                    .map(move |p| {
                        p.next()
                            .map(|evaluated_pow_i| evaluated_pow_i * evaluated_witness)
                    })
                    .collect::<Option<Box<[_]>>>())
                .transpose()
            }
        }

        let count_of_rows = 2usize.pow(S.k as u32);
        let count_of_gates = S.gates.len();

        let n = NonZeroUsize::new(count_of_rows * count_of_gates).unwrap();
        let log_n = NonZeroU32::new(n.ilog2()).unwrap();
        let points_count = (log_n.get() + 1) as usize;

        let mut evaluated_points = ZipWitnessPowIterators {
            evaluated_witness: plonk::iter_evaluate_witness::<C>(S, trace),
            pow_i: lagrange::iter_cyclic_subgroup::<C::ScalarExt>(log_n.get())
                .map(|X| beta + X * delta)
                .map(|challenge| pow_i::iter_eval_of_pow_i(log_n, challenge).unwrap())
                .take(points_count)
                .collect(),
        }
        .par_bridge()
        .try_reduce(
            || vec![C::ScalarExt::ZERO; points_count].into_boxed_slice(),
            |mut poly, evaluated_witness_mul_pow_i| {
                poly.iter_mut()
                    .zip_eq(evaluated_witness_mul_pow_i.iter())
                    .for_each(|(poly, el)| {
                        *poly += el;
                    });

                Ok(poly)
            },
        )?;

        fft::ifft(&mut evaluated_points, log_n.get());

        Ok(UnivariatePoly(evaluated_points))
    }
}
