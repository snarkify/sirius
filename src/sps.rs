use crate::commitment;
use crate::constants::NUM_CHALLENGE_BITS;
use crate::plonk::{eval::Error as EvalError, PlonkInstance};
use crate::poseidon::ROTrait;
use crate::util::fe_to_fe;
use halo2_proofs::arithmetic::CurveAffine;

#[derive(Debug, thiserror::Error, PartialEq)]
pub enum Error {
    #[error(transparent)]
    Eval(#[from] EvalError),
    #[error("Sps verification fail challenge not match at index {challenge_index}")]
    ChallengeNotMatch { challenge_index: usize },
    #[error("For this challenges count table must have lookup aguments")]
    LackOfLookupArguments,
    #[error("Lack of advices, should call `TableData::assembly` first")]
    LackOfAdvices,
    #[error("Only 0..=3 num of challenges supported: {challenges_count} not")]
    UnsupportedChallengesCount { challenges_count: usize },
    #[error("Error while commit {annotation} with err: {err:?}")]
    WrongCommitmentSize {
        annotation: &'static str,
        err: commitment::Error,
    },
}

/// This trait verifies whether the instance is faithly generated by a Special soundness protocol (sps)
/// Reference: section 3.1 of [protostar](https://eprint.iacr.org/2023/620)
pub trait SpecialSoundnessVerifier<C: CurveAffine, RO: ROTrait<C::Base>> {
    fn sps_verify(&self, ro_nark: &mut RO) -> Result<(), Error>;
}

impl<C: CurveAffine, RO: ROTrait<C::Base>> SpecialSoundnessVerifier<C, RO> for PlonkInstance<C> {
    fn sps_verify(&self, ro_nark: &mut RO) -> Result<(), Error> {
        let num_challenges = self.challenges.len();

        if num_challenges == 0 {
            return Ok(());
        }

        ro_nark.absorb_field_iter(self.instance.iter().map(|inst| fe_to_fe(inst).unwrap()));

        for i in 0..num_challenges {
            if ro_nark
                .absorb_point(&self.W_commitments[i])
                .squeeze::<C>(NUM_CHALLENGE_BITS)
                .ne(&self.challenges[i])
            {
                return Err(Error::ChallengeNotMatch { challenge_index: i });
            }
        }
        Ok(())
    }
}
